//Задача 2. Да се напише булева функция, която получава цяло неотрицателно число n и масив от n цели числа. 
//Програмата да проверява дали въведените числа образуват редица „трион“. 
//Редица „трион“ наричаме последователност, за която е вярно, че a1 ≤ a2 ≥ a3 ≤ a4 … 
//или a1 ≥ a2 ≤ a3 ≥ a4 … 

//Използването на функцията да се демонстрира с извикване с примерен масив, 
//стойностите на чиито елементи се въвеждат от стандартния вход.

// 15т.

#include <iostream> 

bool isTrion (int arr[], const int &n) {

    // Хубаво е i и n да са от един тип заради сравнението.
    for (size_t i = 0; i < n; i++) {

        // При i = n - 1 имаме проблем.
        // i + 1 = n и i + 2 = n + 1, и двете са извън масива.
        // Тук проверяваш само първите 3 елемента от тази редица, след това връщаш резултат.
        // Какво ако имам 1 3 2 4 5 6 7 8?
        if (((arr[i] <= arr[i + 1]) && (arr[i + 1] >= arr [i + 2])) 
        || ((arr[i] >= arr[i + 1]) && (arr[i + 1] <= arr [i + 2]))) {
            return true;
        }

        return false;
    }
}

int main () {

    unsigned int SIZE = 1024;

    int arr[SIZE];

    int n;
    std::cin >> n;

    // Валидация за n? Ако имаш n < 0?

    for (size_t i = 0; i < n; i++)
    {
        std::cin >> arr[i];

        // Числата могат да са ти отрицателни. Това не е проблем.
        if (arr[i] < 0) {
        std:: cout << "Invalid input!";
        return 1;
        }
    }

    // Отново същият проблем, както в миналата задача.
    // Функцията можеш да я свалиш в cout-а и да махнеш тази без аргументи.
    isTrion(arr, n);
    std::cout << std::boolalpha << isTrion;

    return 0;
}